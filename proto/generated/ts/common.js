// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: common.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "df.plugin";
export var GameMode;
(function (GameMode) {
    GameMode[GameMode["SURVIVAL"] = 0] = "SURVIVAL";
    GameMode[GameMode["CREATIVE"] = 1] = "CREATIVE";
    GameMode[GameMode["ADVENTURE"] = 2] = "ADVENTURE";
    GameMode[GameMode["SPECTATOR"] = 3] = "SPECTATOR";
    GameMode[GameMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GameMode || (GameMode = {}));
export function gameModeFromJSON(object) {
    switch (object) {
        case 0:
        case "SURVIVAL":
            return GameMode.SURVIVAL;
        case 1:
        case "CREATIVE":
            return GameMode.CREATIVE;
        case 2:
        case "ADVENTURE":
            return GameMode.ADVENTURE;
        case 3:
        case "SPECTATOR":
            return GameMode.SPECTATOR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return GameMode.UNRECOGNIZED;
    }
}
export function gameModeToJSON(object) {
    switch (object) {
        case GameMode.SURVIVAL:
            return "SURVIVAL";
        case GameMode.CREATIVE:
            return "CREATIVE";
        case GameMode.ADVENTURE:
            return "ADVENTURE";
        case GameMode.SPECTATOR:
            return "SPECTATOR";
        case GameMode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseVec3() {
    return { x: 0, y: 0, z: 0 };
}
export const Vec3 = {
    encode(message, writer = new BinaryWriter()) {
        if (message.x !== 0) {
            writer.uint32(9).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(17).double(message.y);
        }
        if (message.z !== 0) {
            writer.uint32(25).double(message.z);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVec3();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 9) {
                        break;
                    }
                    message.x = reader.double();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.y = reader.double();
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.z = reader.double();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            x: isSet(object.x) ? globalThis.Number(object.x) : 0,
            y: isSet(object.y) ? globalThis.Number(object.y) : 0,
            z: isSet(object.z) ? globalThis.Number(object.z) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.x !== 0) {
            obj.x = message.x;
        }
        if (message.y !== 0) {
            obj.y = message.y;
        }
        if (message.z !== 0) {
            obj.z = message.z;
        }
        return obj;
    },
    create(base) {
        return Vec3.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVec3();
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.z = object.z ?? 0;
        return message;
    },
};
function createBaseRotation() {
    return { yaw: 0, pitch: 0 };
}
export const Rotation = {
    encode(message, writer = new BinaryWriter()) {
        if (message.yaw !== 0) {
            writer.uint32(13).float(message.yaw);
        }
        if (message.pitch !== 0) {
            writer.uint32(21).float(message.pitch);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRotation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 13) {
                        break;
                    }
                    message.yaw = reader.float();
                    continue;
                }
                case 2: {
                    if (tag !== 21) {
                        break;
                    }
                    message.pitch = reader.float();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            yaw: isSet(object.yaw) ? globalThis.Number(object.yaw) : 0,
            pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.yaw !== 0) {
            obj.yaw = message.yaw;
        }
        if (message.pitch !== 0) {
            obj.pitch = message.pitch;
        }
        return obj;
    },
    create(base) {
        return Rotation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRotation();
        message.yaw = object.yaw ?? 0;
        message.pitch = object.pitch ?? 0;
        return message;
    },
};
function createBaseBlockPos() {
    return { x: 0, y: 0, z: 0 };
}
export const BlockPos = {
    encode(message, writer = new BinaryWriter()) {
        if (message.x !== 0) {
            writer.uint32(8).int32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).int32(message.y);
        }
        if (message.z !== 0) {
            writer.uint32(24).int32(message.z);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockPos();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.x = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.y = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.z = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            x: isSet(object.x) ? globalThis.Number(object.x) : 0,
            y: isSet(object.y) ? globalThis.Number(object.y) : 0,
            z: isSet(object.z) ? globalThis.Number(object.z) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.x !== 0) {
            obj.x = Math.round(message.x);
        }
        if (message.y !== 0) {
            obj.y = Math.round(message.y);
        }
        if (message.z !== 0) {
            obj.z = Math.round(message.z);
        }
        return obj;
    },
    create(base) {
        return BlockPos.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockPos();
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.z = object.z ?? 0;
        return message;
    },
};
function createBaseItemStack() {
    return { name: "", meta: 0, count: 0 };
}
export const ItemStack = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.meta !== 0) {
            writer.uint32(16).int32(message.meta);
        }
        if (message.count !== 0) {
            writer.uint32(24).int32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseItemStack();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.meta = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.count = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
            count: isSet(object.count) ? globalThis.Number(object.count) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.meta !== 0) {
            obj.meta = Math.round(message.meta);
        }
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        return obj;
    },
    create(base) {
        return ItemStack.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseItemStack();
        message.name = object.name ?? "";
        message.meta = object.meta ?? 0;
        message.count = object.count ?? 0;
        return message;
    },
};
function createBaseBlockState() {
    return { name: "", properties: {} };
}
export const BlockState = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.properties).forEach(([key, value]) => {
            BlockState_PropertiesEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = BlockState_PropertiesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.properties[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            properties: isObject(object.properties)
                ? Object.entries(object.properties).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.properties) {
            const entries = Object.entries(message.properties);
            if (entries.length > 0) {
                obj.properties = {};
                entries.forEach(([k, v]) => {
                    obj.properties[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return BlockState.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockState();
        message.name = object.name ?? "";
        message.properties = Object.entries(object.properties ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseBlockState_PropertiesEntry() {
    return { key: "", value: "" };
}
export const BlockState_PropertiesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockState_PropertiesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return BlockState_PropertiesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockState_PropertiesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseLiquidState() {
    return { block: undefined, depth: 0, falling: false, liquidType: "" };
}
export const LiquidState = {
    encode(message, writer = new BinaryWriter()) {
        if (message.block !== undefined) {
            BlockState.encode(message.block, writer.uint32(10).fork()).join();
        }
        if (message.depth !== 0) {
            writer.uint32(16).int32(message.depth);
        }
        if (message.falling !== false) {
            writer.uint32(24).bool(message.falling);
        }
        if (message.liquidType !== "") {
            writer.uint32(34).string(message.liquidType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.block = BlockState.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.depth = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.falling = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.liquidType = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            block: isSet(object.block) ? BlockState.fromJSON(object.block) : undefined,
            depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
            falling: isSet(object.falling) ? globalThis.Boolean(object.falling) : false,
            liquidType: isSet(object.liquidType) ? globalThis.String(object.liquidType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.block !== undefined) {
            obj.block = BlockState.toJSON(message.block);
        }
        if (message.depth !== 0) {
            obj.depth = Math.round(message.depth);
        }
        if (message.falling !== false) {
            obj.falling = message.falling;
        }
        if (message.liquidType !== "") {
            obj.liquidType = message.liquidType;
        }
        return obj;
    },
    create(base) {
        return LiquidState.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLiquidState();
        message.block = (object.block !== undefined && object.block !== null)
            ? BlockState.fromPartial(object.block)
            : undefined;
        message.depth = object.depth ?? 0;
        message.falling = object.falling ?? false;
        message.liquidType = object.liquidType ?? "";
        return message;
    },
};
function createBaseWorldRef() {
    return { name: "", dimension: "" };
}
export const WorldRef = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.dimension !== "") {
            writer.uint32(18).string(message.dimension);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorldRef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dimension = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            dimension: isSet(object.dimension) ? globalThis.String(object.dimension) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.dimension !== "") {
            obj.dimension = message.dimension;
        }
        return obj;
    },
    create(base) {
        return WorldRef.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorldRef();
        message.name = object.name ?? "";
        message.dimension = object.dimension ?? "";
        return message;
    },
};
function createBaseEntityRef() {
    return { uuid: "", type: "", name: undefined, position: undefined, rotation: undefined };
}
export const EntityRef = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        if (message.position !== undefined) {
            Vec3.encode(message.position, writer.uint32(34).fork()).join();
        }
        if (message.rotation !== undefined) {
            Rotation.encode(message.rotation, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEntityRef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.position = Vec3.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.rotation = Rotation.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : undefined,
            position: isSet(object.position) ? Vec3.fromJSON(object.position) : undefined,
            rotation: isSet(object.rotation) ? Rotation.fromJSON(object.rotation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.position !== undefined) {
            obj.position = Vec3.toJSON(message.position);
        }
        if (message.rotation !== undefined) {
            obj.rotation = Rotation.toJSON(message.rotation);
        }
        return obj;
    },
    create(base) {
        return EntityRef.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEntityRef();
        message.uuid = object.uuid ?? "";
        message.type = object.type ?? "";
        message.name = object.name ?? undefined;
        message.position = (object.position !== undefined && object.position !== null)
            ? Vec3.fromPartial(object.position)
            : undefined;
        message.rotation = (object.rotation !== undefined && object.rotation !== null)
            ? Rotation.fromPartial(object.rotation)
            : undefined;
        return message;
    },
};
function createBaseDamageSource() {
    return { type: "", description: undefined };
}
export const DamageSource = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDamageSource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return DamageSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDamageSource();
        message.type = object.type ?? "";
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseHealingSource() {
    return { type: "", description: undefined };
}
export const HealingSource = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHealingSource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return HealingSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHealingSource();
        message.type = object.type ?? "";
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseAddress() {
    return { host: "", port: 0 };
}
export const Address = {
    encode(message, writer = new BinaryWriter()) {
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        if (message.port !== 0) {
            writer.uint32(16).int32(message.port);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.port = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            host: isSet(object.host) ? globalThis.String(object.host) : "",
            port: isSet(object.port) ? globalThis.Number(object.port) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.host !== "") {
            obj.host = message.host;
        }
        if (message.port !== 0) {
            obj.port = Math.round(message.port);
        }
        return obj;
    },
    create(base) {
        return Address.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddress();
        message.host = object.host ?? "";
        message.port = object.port ?? 0;
        return message;
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
