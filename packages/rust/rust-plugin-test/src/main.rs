use my_bedrock_api::{
    Plugin,                            // The plugin runner
    Server,                            // The handle to the server
    async_trait,                       // Required by PluginEventHandler
    bedrock_plugin,                    // The "magic" macro
    event_context::EventContext,       // The event wrapper
    event_handler::PluginEventHandler, // The main trait
    types,                             // All the raw prost/tonic types
};

// --- 2. Define a struct for your plugin's state ---
// It can be empty, or it can hold databases, configs, etc.
// We add `Default` so it's easy to create.
#[derive(Default)]
struct MyExamplePlugin;

// --- 3. Implement the event handlers ---
//
// * We add `#[bedrock_plugin]` to this block.
//   This macro will scan for every `on_...` function we implement
//   and automatically generate the `impl PluginSubscriptions` for us.
//
// * We add `#[async_trait]` because the trait uses async functions.

#[bedrock_plugin]
#[async_trait]
impl PluginEventHandler for MyExamplePlugin {
    /// This handler runs when a player joins the server.
    /// We'll use it to send our "hello world" message.
    async fn on_player_join(
        &self,
        server: &Server,
        event: &mut EventContext<types::PlayerJoinEvent>,
    ) {
        // Log to the plugin's console
        println!("Player '{}' has joined the server.", event.data.name);

        // Send a public, broadcasted chat message.
        // We assume `send_chat` was generated by `xtask` from a `SendChatAction`.
        let welcome_message = format!(
            "Welcome, {}! This server is running MyExamplePlugin.",
            event.data.name
        );

        // We call the auto-generated `server.send_chat` helper.
        // `.await.ok()` sends the message and ignores any potential
        // (but rare) connection errors.
        server.send_chat(welcome_message).await.ok();
    }

    /// This handler runs every time a player sends a chat message.
    /// We'll use it to edit the message.
    async fn on_chat(
        &self,
        _server: &Server, // We don't need the server handle for this
        event: &mut EventContext<types::ChatEvent>,
    ) {
        // Get the original message from the event's data
        let original_message = &event.data.message;

        // Create the new message
        let new_message = format!("[Plugin] {}", original_message);

        // Use the auto-generated `set_message` helper to
        // mutate the event before the server processes it.
        event.set_message(new_message);
    }

    // We don't implement `on_player_hurt`, `on_block_break`, etc.,
    // so the `#[bedrock_plugin]` macro will not subscribe to them.
}

// --- 4. The main function to run the plugin ---
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Define the plugin's metadata
    let plugin = Plugin::new(
        "example-plugin",    // A unique ID for your plugin
        "My Example Plugin", // A human-readable name
        "1.0.0",             // Your plugin's version
        "1.0.0",             // The API version you're built against
    );

    // 2. Connect to the server and run the plugin
    println!("Connecting to Bedrock server...");

    plugin
        .run(
            MyExamplePlugin::default(), // Pass in an instance of our handler
            "http://[::1]:50051",       // The server address
        )
        .await
}
